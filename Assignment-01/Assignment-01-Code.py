# -*- coding: utf-8 -*-
"""Copy of Com Eng Math 2 1/2022 - Assignment 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1thHB_ez7s9BVVTjUDAMgXEEb81FuGJhk

# **<< Only problem 3.1 will be graded. >>**

## Linear optimization example

Ex. A small startup hardware company is selling smart gadgets. This company has two main products which are smartwatches, and smart TVs sold for 1,200 and 5,000 THB, respectively. The company decides that they will buy a 3D printer to manufacture their products instead of using Chinese factories. After some testing, a printer could produce a maximum of 50 watches or 10 TVs per day. Due to the issues with logistics a total 55 items could be produced per day. For the maintenance issue, at least 3 TVs have to be produced per day. Assuming that the demand for both items is unlimited, the company asks you how many watches and TVs should they produce per single printer to maximize revenue.

To solve this problem, first, we have to formulate this problem as a mathematical program.

To model the program we should :

1. Identifying the decision variable.
2. Identifying the objective.
3. Identifying the constraints.

A mathematical program for this example is :

####Decision variable

$x_1$ : The amount of smartwatches produced per day </br> $x_2$ : The amount of TVs produced per day

$$Objective : max( 1200x_1 + 5000x_2) $$
\begin{equation*}
s.t.
\begin{split}
  \frac{1}{50}x_1 + \frac{1}{10}x_2 & \leq 1 \\
  x_1 + x_2 & \leq 55 \\
  x_2 & \geq 3 \\
  x_1, x_2 & \geq 0 \\
\end{split}
\end{equation*}

After the linear program is modeled, we then convert the program into a  standard form.

$$Objective : min( - 1200x_1 - 5000x_2) )$$
\begin{equation*}
s.t.
\begin{split}
  \frac{1}{50}x_1 + \frac{1}{10}x_2 + x_3 & = 1 \\
  x_1 + x_2 + x_4 & = 55 \\
  x_2 -x_5 & =  3 \\
  x_1, x_2, x_3, x_4, x_5 & \geq 0 \\
\end{split}
\end{equation*}


After the problem is converted into a standard form, we then convert it into a matrix form.

\begin{split}
  min \;\;\;  \mathbf{c}^T \mathbf{x} \\
  s.t. \; \mathbf{A}\mathbf{x} = \mathbf{b} \\
  \mathbf{x} \geq 0
\end{split}

$$
where \;\;
\begin{align}
  \mathbf{c} &= \begin{bmatrix}
          -1200 \\
          -5000 \\
          0 \\
          0 \\
          0 \\
        \end{bmatrix},
        \mathbf{A} = \begin{bmatrix}
          \frac{1}{50} & \frac{1}{10} & 1 & 0 & 0 \\
          1 & 1 & 0 & 1 & 0 \\
          0 & 1 & 0 & 0 & -1  \\
        \end{bmatrix},
        \mathbf{x} = \begin{bmatrix}
          x_{1} \\
          x_{2} \\
          x_{3} \\
          x_{4} \\
          x_{5} \\
        \end{bmatrix},
         \mathbf{b} = \begin{bmatrix}
          1 \\
          55 \\
          3
        \end{bmatrix}
\end{align}
$$

After the matrix from is obtained, we then feed the matrixs into a linear optimization library to solve for an optimal solution and optimal value.

## Import library
"""

from scipy.optimize import linprog
import numpy as np

"""## Creating a matrix form of the problem



"""

c_T = np.array([-1200, -5000, 0, 0, 0])
A = np.array(
    [
     [1/50     , 1/10   , 1,  0,  0],
     [1          , 1        , 0, 1,  0],
     [0          , 1        , 0, 0, -1],
    ]
)
bound = [[0, None], [0, None], [0, None], [0, None], [0, None]] # bound for each variables (0, inf)
b = [1, 55, 3]

"""## Solving the optimization problem
It was found that x = [35, 3, 0, 17, 0], which means that we should produce 35 watches and 3 TVs per day.
"""

result = linprog(c = c_T, A_eq = A, b_eq=b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x)) # actual optimal value is 57000

"""## Example of wrong matrix formation

Instead of producing at least 3 TVs, we mistype and produce at least 15 TVs instead. Thus, a feasible solution could not be found.

"""

new_b = [1, 55, 15]
result = linprog(c = c_T, A_eq = A, b_eq = new_b, bounds=bound, method='simplex')
print(result)

"""If we remove the production constraint. The solution becomes unbounded."""

c_T = np.array([-1200, -5000,  0])
A = np.array(
    [
     [0, 1, -1]
    ]
)
bound = [[0, None], [0, None], [0, None],] # bound for each variables (0, inf)
b = [3]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print(result)

"""## Tips and tricks

You can create an identiy matrix by using `np.eye`.
"""

x = np.eye(5)
print(x)

y = np.zeros((8, 8))
x = np.eye(5)
y[2: 7, 2: 7] =x
print(y)

"""You can also index data diaganolly."""

a = np.array([3, 2, 1])
print(np.diag(a))

y = np.zeros((6, 6))
y[2: 5, 2: 5] =np.diag(a)
print(y)

y = np.zeros((6, 6))
di  = np.diag_indices(len(a))
y[di] = a
print(y)
y[di[0], di[1] + 1] = a* 2
print(y)

# another useful python trick
bound = [[0, None]] * 5
print(bound)

"""## Problem 1 : Skill Check

Solve the following program :
$$Objective : max(3x + 4y) $$
\begin{equation*}
s.t.
\begin{split}
  x + 2y & \leq 7 \\
  3x  - y & \geq 0 \\
  x -  y & \leq  2 \\
  x, y & \geq 0 \\
\end{split}
\end{equation*}


"""

c_T = np.array([-3, -4, 0, 0, 0])
A = np.array(
    [
     [1,    2,    1,    0,    0],
     [3,    -1,   0,    -1,    0],
     [1,    -1,   0,    0,    1]
    ]
)
bound = [[0, None]]*5 # bound for each variables (0, inf)
b = [7, 0, 2]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,-result.fun, result.x[:2]))

"""## Problem 1.2 :

Solve problem 1 by using a graphical method and draw an isoprofit line. Does the obtained solution the same as the one we get in problem 1? You can solve this problem on your tablet/paper or use a plotting library.
"""

# basic matplotlib command
import matplotlib.pyplot as plt
x = np.linspace(0, 1000, 100)
y = 2 * x + 1
y2 = -x +  49

min_y, max_y = -10000, 10000

plt.figure(figsize = (5, 5))
plt.xlim(0, 100)
plt.ylim(0, 100)
plt.title('y = 2x + 1, y = -x + 49')
plt.plot(x , y, color = 'green' , label = 'y = 2x+1')
plt.fill_between(x, y, min_y, color = 'red', alpha = 0.3, label = 'area under')
plt.fill_between(x, y, max_y, color = 'blue', alpha = 0.3, label = 'area above')

plt.plot(x , y2, color = 'orange', label = 'y = -x+49')
plt.fill_between(x, y2, min_y, color = 'yellow', alpha = 1)

# plt.scatter(16, 33, s = 100, color = 'purple',  label = 'intersection point')
plt.legend()
plt.grid(color = 'black')

plt.show()

"""## Problem 2 : Hamtaro factory

After Hamtaro finished planting the sunflower field, he then aims to open the Hamtaro factory, selling sunflower snacks to the fellow hamsters. However, the harvested sunflower seeds have different grades, which leads to different nutrition values. Nutrition values for each grade are shown in the table below. To sell the snack at the market, the HFA (Hamster Food Administration) states that the snack they produce must contain at least 60% protein and no more than 5% fat. To minimize the ingredient cost, how should Hamtaro mix the sunflower seeds to pass the HFA approval? Formulate the problem as a linear program and solve for an optimal solution.

|  sunflower seed grade | % protein| % fat |cost per g (THB) |
|:-----------------:|:------------:|:------------:|:------------:|
| terrible | 25 | 10 | 0.01 |
| low | 40  | 7 | 0.3 |
| medium | 70 | 4 | 0.7 |
| high | 90 | 1 | 1.2  |


"""

# Let T, L, M, H be ratio of each seed type
#
# T + L + M + H = 1
#
# 25T + 40L + 70M + 90H >= 60
# -> 25T + 40L + 70M + 90H - e = 60
#
# 10T + 7L + 4M + 1H <= 5
# -> 10T + 7L + 4M + H + s = 5
#
# find min of 0.01T + 0.3L + 0.7M + 1.2H

c_T = np.array([0.01, 0.3, 0.7, 1.2, 0, 0, 0])
A = np.array(
    [
     [25,  40,  70,  90,  -1,  0  ,0],
     [10,  7,   4,   1,   0,   1  ,0],
     [1,   1,   1,   1,   0,   0  ,0],
     [0,   0,   0,   1,   0,   0  ,-1]
    ]
)
bound = [[0, None]]*7 # bound for each variables (0, inf)
b = [60, 5, 1, 0.25]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x[:4]))

"""## Problem 3.1 : Storage server management

A company is running a video analytic system. To store the analyzed videos, the company has 10 local storage servers to store the data, of which each of them could store 24 TB per server. Recently, the company finds out that the servers  they have will not be adequate in the recent future. Therefore, the company has to figure out a plan to scale up its resource. The CTO has come up with two solutions, which are buying new storage servers, and using a cloud storage service called 'SWA S3'. The cloud storage service charges 690 THB/TB per month. On the other hand, buying a new server costs 40,000 THB, but it could be used for a very long time.  After several discussions, the company has projected the amount of storage required for each month. The projected data is shown in the table below. To minimize the cost, what should the company do to store the data? Formulate the problem as a linear program and solve for an optimal solution.

**Note 1 : The optimal solution does not have to be an integer.** </br>
**Note 2 : The company could buy new servers at any month.**

|  Month | 1  |  2 |  3 |  4 | 5 | 6 | 7 | 8 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| Estimated amount of storage required (TB) | 140 | 200 | 300 | 1000 | 1400| 500 | 600 | 900 | 700 |


"""

# decision variables: Nx is the number of new servers bought in month x
#                     Cx is the number of TB using cloud system in month x
#
# objective: min(40000(N1 + N2 + N3 + N4 + N5 + N6 + N7 + N8) + 690(C1 + C2 + C3 + C4 + C5 + C6 + C7 + C8))
#
# constraints:  24(N1)                                    + C1 >= 0     ->  24(N1)                                    + C1 - E1 = 0
#               24(N1 + N2)                               + C2 >= 0     ->  24(N1 + N2)                               + C2 - E2 = 0
#               24(N1 + N2 + N3)                          + C3 >= 60    ->  24(N1 + N2 + N3)                          + C3 - E3 = 60
#               24(N1 + N2 + N3 + N4)                     + C4 >= 760   ->  24(N1 + N2 + N3 + N4)                     + C4 - E4 = 760
#               24(N1 + N2 + N3 + N4 + N5)                + C5 >= 1160  ->  24(N1 + N2 + N3 + N4 + N5)                + C5 - E5 = 1160
#               24(N1 + N2 + N3 + N4 + N5 + N6)           + C6 >= 260   ->  24(N1 + N2 + N3 + N4 + N5 + N6)           + C6 - E6 = 260
#               24(N1 + N2 + N3 + N4 + N5 + N6 + N7)      + C7 >= 360   ->  24(N1 + N2 + N3 + N4 + N5 + N6 + N7)      + C7 - E7 = 360
#               24(N1 + N2 + N3 + N4 + N5 + N6 + N7 + N8) + C8 >= 660   ->  24(N1 + N2 + N3 + N4 + N5 + N6 + N7 + N8) + C8 - E8 = 660
#               when Ex is excess variable
#               Ex >= 0 for all x = 1 to 8
#               Nx >= 0 for all x = 1 to 8
#               Cx >= 0 for all x = 1 to 8

c_T = np.array([40000]*8 + [690]*8 + [0]*8)

# create A
A = np.zeros((8, 24))
lower_triangle_matrix = np.tril(np.ones((8, 8)), k=0)
A[::, 0:8] = lower_triangle_matrix*24
A[::, 8:16] = np.eye(8)
A[::, 16:24] = -np.eye(8)

bound = [[0, None]]*24 # bound for each variables (0, inf)

b = [0, 0, 60, 760, 1160, 260, 360, 660]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x[:16]))

"""## Problem 3.2
From problem 3. Would the optimal solution change if the company has to pay 2,000 THB maintenance  fee per month for each local storage server they have?
"""

# decision variables: Nx is the number of new servers bought in month x
#                     Cx is the number of TB using cloud system in month x
#
# objective: min(40000(N1 + N2 + N3 + N4 + N5 + N6 + N7 + N8) + 2000(8*N1 + 7*N2 + 6*N3 + 5*N4 + 4*N5 + 3*N6 + 2*N7 + 1*N8) + 690(C1 + C2 + C3 + C4 + C5 + C6 + C7 + C8) + 2000*8*10)
#
# constraints:  24(N1)                                    + C1 >= 0     ->  24(N1)                                    + C1 - E1 = 0
#               24(N1 + N2)                               + C2 >= 0     ->  24(N1 + N2)                               + C2 - E2 = 0
#               24(N1 + N2 + N3)                          + C3 >= 60    ->  24(N1 + N2 + N3)                          + C3 - E3 = 60
#               24(N1 + N2 + N3 + N4)                     + C4 >= 760   ->  24(N1 + N2 + N3 + N4)                     + C4 - E4 = 760
#               24(N1 + N2 + N3 + N4 + N5)                + C5 >= 1160  ->  24(N1 + N2 + N3 + N4 + N5)                + C5 - E5 = 1160
#               24(N1 + N2 + N3 + N4 + N5 + N6)           + C6 >= 260   ->  24(N1 + N2 + N3 + N4 + N5 + N6)           + C6 - E6 = 260
#               24(N1 + N2 + N3 + N4 + N5 + N6 + N7)      + C7 >= 360   ->  24(N1 + N2 + N3 + N4 + N5 + N6 + N7)      + C7 - E7 = 360
#               24(N1 + N2 + N3 + N4 + N5 + N6 + N7 + N8) + C8 >= 660   ->  24(N1 + N2 + N3 + N4 + N5 + N6 + N7 + N8) + C8 - E8 = 660
#               when Ex is excess variable
#               Ex >= 0 for all x = 1 to 8
#               Nx >= 0 for all x = 1 to 8
#               Cx >= 0 for all x = 1 to 8

# create c_T
c_T = np.zeros(24)
c_T[:8] = np.array(range(9))[:0:-1]*2000 + np.ones(8)*40000
c_T[8:16] = np.ones(8)*690
print(c_T)

# create A
A = np.zeros((8, 24))
lower_triangle_matrix = np.tril(np.ones((8, 8)), k=0)
A[::, 0:8] = lower_triangle_matrix*24
A[::, 8:16] = np.eye(8)
A[::, 16:24] = -np.eye(8)

bound = [[0, None]]*24 # bound for each variables (0, inf)

b = [0, 0, 60, 760, 1160, 260, 360, 660]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun + 2000*8*10, result.x[:16]))

"""## Problem 4 : Task assignment

A data center company has a lot of servers to be maintained. Thus, the maintainers are required 24/7. To maintain the servers, the company has employed four technicians, of which one of them is a senior. Each technician has to work at least 40 hours per week, except for the senior one, which works exactly 36 hours per week. The wage is paid hourly, and every technician has different wages and availability. The maintenance is performed with exactly one person on duty.  How should the company assign each person to be on duty to minimize the maintenance cost? Formulate the problem as a linear program and solve for an optimal solution.

<table>
  <tr>
    <td><b>Technician</td>
    <td><b>Wage per hour(weekday)</td>
    <td><b>Wage per hour(weekend)</td>
    <td colspan="7"><b>Maximum hours of avaiability</td>
  </tr>
  <tr>
    <td colspan="3"><b></td>
    <td><b>Mon.</td>
    <td><b>Tue.</td>
    <td><b>Wed.</td>
    <td><b>Thurs.</td>
    <td><b>Fri.</td>
    <td><b>Sat.</td>
    <td><b>Sun.</td>
  </tr>
  <tr>
    <td >Technician A</td>
    <td >70</td>
    <td >80</td>
    <td >12</td>
    <td >10</td>
    <td >12</td>
    <td >0</td>
    <td >8</td>
    <td >8</td>
    <td >4</td>
  </tr>
  <tr>
    <td >Technician B</td>
    <td >70</td>
    <td >80</td>
    <td >12</td>
    <td >10</td>
    <td >0</td>
    <td >8</td>
    <td >8</td>
    <td >4</td>
    <td >8</td>
  </tr>
  
  <tr>
    <td >Technician C</td>
    <td >80</td>
    <td >75</td>
    <td >0</td>
    <td >10</td>
    <td >8</td>
    <td >8</td>
    <td >0</td>
    <td >10</td>
    <td >10</td>
  </tr>
  
  <tr>
    <td >Senior technician D</td>
    <td >160</td>
    <td >200</td>
    <td >24</td>
    <td >0</td>
    <td >24</td>
    <td >24</td>
    <td >24</td>
    <td >24</td>
    <td >24</td>
  </tr>
  


</table>

"""

# create c_T
c_T = np.array([70]*5 + [80]*2 + [70]*5 + [80]*2 + [80]*5 + [75]*2 + [160]*5 + [200]*2 + [0]*32)

# create A
A = np.zeros((39, 60))

# upper bound
A[:28, :28] = np.eye(28)
A[:28, 28:56] = np.eye(28)

# 24 hour of each day
A[28:35, :7] = np.eye(7)
A[28:35, 7:14] = np.eye(7)
A[28:35, 14:21] = np.eye(7)
A[28:35, 21:28] = np.eye(7)

# hour of each tech
A[35, :7] = np.ones(7)
A[36, 7:14] = np.ones(7)
A[37, 14:21] = np.ones(7)
A[38, 21:28] = np.ones(7)
A[35:38, 56:59] = -np.eye(3)

bound = [[0, None]]*60

b = [12, 10, 12, 0, 8, 8, 4,
     12, 10, 0, 8, 8, 4, 8,
     0, 10, 8, 8, 0, 10, 10,
     24, 0, 24, 24, 24, 24, 24] + [24]*7 + [40, 40, 40, 36]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x))
print("A : {} {}".format(result.x[:7].sum(), result.x[:7]))
print("B : {} {}".format(result.x[7:14].sum(), result.x[7:14]))
print("C : {} {}".format(result.x[14:21].sum(), result.x[14:21]))
print("D : {} {}".format(result.x[21:28].sum(),result.x[21:28]))

"""## Problem 5 : Courier service

A company named "Curry" provides courier services to the customer. In town X, 10 customers are using this company's service. To satisfy the demand in this town, the company has placed the courier office as a hub for the couriers to collect customers' packages. However, only a limited amount of packages could be stockpiled in each office. The company has to pay the couriers 10 THB per kg per distance they have traveled in kilometer. Moreover, the package could be partially collected (divisible), i.e., a courier from office A and C could collect 200 kg, 300 kg package from customer 1. How should this company plan to send the couriers to collect the package such that the package collection cost is minimized? The amount of packages to be collected for each customer is shown in Table 2.1. The size of each package storage is shown in Table 2.2. The distance from the courier office to each customer is shown in Table 2.3. Formulate the problem as a linear program and solve for an optimal solution.

**Note :  The optimal solution does not have to be an integer.**


Table 2.1. Amount of packages to be collected for each customer.

|  Customer | 1  |  2 |  3 |  4 | 5 | 6 | 7 | 8 | 9 | 10 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| Amount of packages to be collected (kg) | 500 | 200 | 1000 | 2000 | 150 | 20 | 350 |250 | 375 | 1

Table 2.2. The size of package storage for each office.

|  Office | Storage size (kg)|
|:-----------------:|:------------:|
| A | 1500 |
| B | 1000 |
| C | 4000 |

Table 2.3. Distance from the office to each household (km)

|  From / to | 1  |  2 |  3 |  4 | 5 | 6 | 7 | 8 | 9 | 10 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| A | 4 | 3 | 8 | 1 | 2 | 1 | 3 | 2 | 4 | 4 |
| B | 3 | 1 | 1 | 8 | 3 | 4 | 5 | 7 | 9 | 8 |
| C | 8 | 6 | 5 | 3 | 1 | 6 | 7 | 2 | 7 | 5 |



"""

# create c_T
c_T = np.array([4, 3, 8, 1, 2, 1, 3, 2, 4, 4,
                3, 1, 1, 8, 3, 4, 5, 7, 9, 8,
                8, 6, 5, 3, 1, 6, 7, 2, 7, 5] + 13*[0])*10

# create A
A = np.zeros((13, 43))
A[0, :10] = np.ones(10)
A[1, 10:20] = np.ones(10)
A[2, 20:30] = np.ones(10)
A[3:13, :10] = np.eye(10)
A[3:13, 10:20] = np.eye(10)
A[3:13, 20:30] = np.eye(10)
A[:3, 30:33] = np.eye(3)
A[3:, 33:43] = -np.eye(10)

bound = [[0, None]]*43

b = [1500, 1000, 4000, 500, 200, 1000, 2000, 150, 20, 350, 250, 375, 1]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x[:30]))

"""## Problem 6: VM placement

A startup company is provisioning virtual machines (VM) for cloud computing.  Currently, the company offers three types of instances, which are a small, medium, and large instance. The detail for each type of instance is shown in the table below. To host the VMs, the company has a large number of servers to provide its service. All of the servers they possessed have 8 CPUs core. Recently, the company has found a new customer to use their service. The customer want to host 20 small, 9 medium, and 5 large instances for their company. Moreover, the customer also demands that only they could access the provided server, i.e., the company could not use the leftover CPUs to serve other customers despite having 2 CPUs left. How many servers should the company allocate to serve this customer? Formulate the problem as a linear program and solve for an optimal solution.

|  Instance type |    Number of CPUs provided   |
|:-----------------:|:------------:|
| small | 2 CPUs |
| medium | 3 CPUs |
| large   | 4 CPUs |

**Note : The optimal solution does not have to be an integer.** </br>
**Hint : How many way could we fit the instances into a single server?**

"""

# S1 S2 S3 S4
# M1 M2
# L1 L2
# S1M1 S1M2 S1L1
# S2M1 S2L1
# M1L1

# create c_T
c_T = np.array([1]*14)

# create A
A = np.array([
    [1, 2, 3, 4, 0, 0, 0, 0, 1, 1, 1, 2, 2, 0],
    [0, 0, 0, 0, 1, 2, 0, 0, 1, 2, 0, 1, 0, 1],
    [0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 1, 0, 1, 1]
])

bound = [[0, None]]*14

b = [20, 9, 5]
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x[:14]))

"""
## Problem 7: Linear binary classification model (Maximal Margin Classifier)

This problem will introduce you to a basic machine learning classification algortithm. Let's say that we have the dataset $D = \{ (x_0, y_0), (x_1, y_1), ..., (x_n, y_n)\}$. Each element in $D$ is a datapoint $x_i$ in a form of tuple $(x_0, x_1)$ which belong to the class  $y_i \in \{-1, 1\}$. Machine learning alogrithm aims to represent the dataset $D$ using sets of parameter $\mathbf{\theta}$.  For classification task, we use machine learning alogrithm to correctly classify the class $y$ given the datapoint $x$.

In this problem, we use a linear line $\theta_0x_0 + \theta_1x_1 + \theta_2 = 0$ as a classifier.  The datapoints above and below the line will be classified as class 1 (positive) and -1 (negative) respectively. The objective of this problem is to find the parameters of the linear classifier $\mathbf{\theta}$ given $D$ by formulating the problem as a linear program. A figure below demonstrates that the line with the parameter $ (\theta_0, \theta_1, \theta_2) = (1.5, 1, -5)$, i.e., $1.5x_0 + x_1 - 5 = 0$,  could seperate the data into two classes.  
"""

import matplotlib.pyplot as plt

class_a = np.random.randn(10, 2)* 0.5 # generate class -1 data
class_b = np.random.randn(10, 2) * 0.5  + 5# generte class 1 data

print(class_a[0]) # example of datapoint

def generate_decision_boundary(theta_0, theta_1, theta_2, xmin = -10,  ymin = -10, xmax = 10, ymax = 10, h = 0.1):
  '''
    Input : Parameter theta_0, theta_1, theta_2 of a linear classifier
    Output : Decision boundary ( 1 is positive, -1 is negative, 0 is seperating hyperplane)
  '''
  x_0, x_1 = np.meshgrid(np.arange(xmin, xmax, h), np.arange(ymin, ymax, h))
  prediction = theta_0 * x_0 + theta_1 * x_1 + theta_2
  prediction[prediction > 0] = 1
  prediction[prediction < 0] = -1
  return (x_0, x_1, prediction)

theta_0 = 1.5
theta_1 = 1
theta_2 = -5
decision_boundary = generate_decision_boundary(theta_0, theta_1, theta_2)

plt.figure(figsize = (5, 5))
plt.xlim(-4.5, 9)
plt.ylim (-4.5, 9)

plt.scatter(class_a[:, 0], class_a[:, 1], color = 'red', label = 'class -1')
plt.scatter(class_b[:, 0], class_b[:, 1], color = 'green', label = 'class 1')
plt.contourf(decision_boundary[0], decision_boundary[1], decision_boundary[2], cmap = 'RdYlGn', alpha = 0.1) # plot decision boundary
plt.xlabel('x_0')
plt.ylabel('x_1')
plt.title('green area is 1.5x_0 + x_1 - 5 > 0, red area is 1.5x_0 + x_1 - 5 < 0')
plt.legend()
plt.show()

"""As you can see, the line $\theta_0x_0 + \theta_1x_1 + \theta_2 = 0$ could seperate the data into two classes by constraining $x_i$ which has the value of $\theta_0x_{i,0} + \theta_1x_{i,1} + \theta_2 > 0$ into a positive class $(y_i = 1)$ and $\theta_0x_{i,0} + \theta_1x_{i,1} + \beta_2 < 0$ into a negative class $(y_i = -1)$. Therefore, the value of $\theta$ could optimized by constraining the line to satisfy the condition of every datapoints w.r.t. its class, which result in the mathematical program shown below.

$$Objective : - $$
\begin{equation*}
s.t.
\begin{split}
  \theta_0x_{i, 0} + \theta_1x_{i, 1} + \theta_2   & > 0 \\
  \theta_0x_{j, 0} + \theta_1x_{j, 1} + \theta_2   & < 0 \\
  \forall i, y_i & = 1 \\
  \forall j, y_j & = -1 \\
\end{split}
\end{equation*}

The program could also be written in a form of:

$$Objective : - $$
\begin{equation*}
s.t.
\begin{split}
  \forall i, y_i(\theta_0x_{i, 0} + \theta_1x_{i, 1} + \theta_2)   & > 0 \\
\end{split}
\end{equation*}

The program above could return a feasible solution yet the wellness of the optimized value is not defined. For example, $H_2$ and $H_3$ in the image below are both acceptable solution using the program above. However, $H_3$ might be a preferred solution.

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b5/Svm_separating_hyperplanes_%28SVG%29.svg" width="30%" >


Image source: https://upload.wikimedia.org/wikipedia/commons/b/b5/Svm_separating_hyperplanes_%28SVG%29.svg

Thus, we introduce the margin $\epsilon$ to define the wellness of the program.  The margin is the shortest distance from the hyperplane to the closest datapoint. Maximizing $\epsilon$ would result in the line which has the largest separation between the two classes (maximum margin). As a result, the program becomes:

$$Objective : max(\epsilon) $$
\begin{equation*}
s.t.
\begin{split}
  \theta_0x_{i, 0} + \theta_1x_{i, 1} + \theta_2   & \geq \epsilon \\
  \theta_0x_{j, 0} + \theta_1x_{j, 1} + \theta_2   & \leq  -\epsilon \\
  \forall i, y_i & = 1 \\
  \forall j, y_j & = -1 \\
  \theta_0, \theta_1 & \in [-1,1] \\
\end{split}
\end{equation*}

The program could also be written in a form of:

$$Objective : max(\epsilon) $$
\begin{equation*}
s.t.
\begin{split}
  \forall i, y_i(\theta_0x_{i, 0} + \theta_1x_{i, 1} + \theta_2)   & \geq \epsilon \\
   \theta_0, \theta_1 & \in [-1,1] \\
\end{split}
\end{equation*}

 $ \theta_0, \theta_1 $ are both bounded to $[-1,1]$ to prevent unbounded solution.

<b> Note: This is a simplified version of a linear support vector machine and many details are omitted. You can read more at https://en.wikipedia.org/wiki/Support-vector_machine#Linear_SVM if interested.

###Problem 7.1
Convert the mathematical program above into a linear program. Then, use the converted program to solve for the line seperating the datapoints below. <b> Do not forget to visualize the solved line.
"""

class_a = np.array([[np.random.uniform(2.1, 3), np.random.uniform(2.3, 4)] for _ in range(20)]) # class -1 data
class_b = np.array([[np.random.uniform(-1, 2), np.random.uniform(0, 2.2)] for _ in range(20)]) # class 1 data
print(class_a.shape)

plt.figure(figsize = (5, 5))
plt.scatter(class_a[:, 0], class_a[:, 1], color = 'red', label = 'class -1')
plt.scatter(class_b[:, 0], class_b[:, 1], color = 'green', label = 'class 1')
plt.legend()
plt.show()

# create c_T
c_T = np.zeros((A.shape[1]))
c_T[-1] = -1

# create A
class_a_x = np.concatenate( (class_a, np.ones((class_a.shape[0], 1))), axis=1 )
class_b_x = np.concatenate( (class_b, np.ones((class_b.shape[0], 1))), axis=1 )
dataset = np.concatenate( (class_a_x, -class_b_x))
slack_var = -np.eye(dataset.shape[0])
epsilon = -np.ones((dataset.shape[0], 1))
A = np.concatenate( (dataset, slack_var, epsilon), axis=1 )

bound = [[-1, 1]]*2 + [[None, None]] + [[0, None]]*41

b = [0]*40
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x[:4]))

# objective: min(-e)
# variables:
# constraints:

# create c_T
c_T = np.array([0]*3 + [-1] + [0]*40)

# create A
A = np.zeros((40, 44))

for i in range(20):
  A[i, 0] = class_a[i, 0]
  A[i, 1] = class_a[i, 1]
  A[i+20, 0] = -class_b[i, 0]
  A[i+20, 1] = -class_b[i, 1]

# theta_2
A[:20, 2] = np.ones(20)
A[20:, 2] = -np.ones(20)
A[:, 3] = -np.ones(40)
A[:, 4:] = -np.eye(40)

bound = [[-1, 1]]*2 + [[None, None]] + [[0, None]]*41

b = [0]*40
result = linprog(c = c_T, A_eq = A, b_eq = b, bounds=bound, method='simplex')
print("{}\n\n optimal value is {} \n optimal soultion is {}".format(result,result.fun, result.x[:4]))

theta_0 = result.x[0]
theta_1 = result.x[1]
theta_2 = result.x[2]
E = -result.x[3]

def generate_decision_boundary(theta_0, theta_1, theta_2, xmin = -10,  ymin = -10, xmax = 10, ymax = 10, h = 0.1):
  '''
    Input : Parameter theta_0, theta_1, theta_2 of a linear classifier
    Output : Decision boundary ( 1 is positive, -1 is negative, 0 is seperating hyperplane)
  '''
  x_0, x_1 = np.meshgrid(np.arange(xmin, xmax, h), np.arange(ymin, ymax, h))
  prediction = theta_0 * x_0 + theta_1 * x_1 + theta_2
  prediction[prediction > E] = 1
  prediction[prediction < -E] = -1
  return (x_0, x_1, prediction)

decision_boundary = generate_decision_boundary(theta_0, theta_1, theta_2)

plt.figure(figsize = (5, 5))
plt.xlim(-2, 5)
plt.ylim (-2, 5)

plt.scatter(class_a[:, 0], class_a[:, 1], color = 'red', label = 'class -1')
plt.scatter(class_b[:, 0], class_b[:, 1], color = 'green', label = 'class 1')
plt.contourf(decision_boundary[0], decision_boundary[1], decision_boundary[2], cmap = 'RdYlGn', alpha = 0.1) # plot decision boundary
plt.xlabel('x_0')
plt.ylabel('x_1')
plt.title('green area is 1.5x_0 + x_1 - 5 > 0, red area is 1.5x_0 + x_1 - 5 < 0')
plt.legend()
plt.show()

"""###Problem 7.2
Given the datapoints below, repeat 7.1 and observe the result. What is happening to the solution and why does this happen?
"""

class_a = np.random.uniform(0, 2, (20, 2) ) # class -1 data
class_b = np.random.uniform(0.5, 3, (20, 2)) # class 1 data

plt.figure(figsize = (5, 5))
plt.scatter(class_a[:, 0], class_a[:, 1], color = 'red', label = 'class -1')
plt.scatter(class_b[:, 0], class_b[:, 1], color = 'green', label = 'class 1')
plt.legend()
plt.show()

plt.figure(figsize = (5, 5))

plt.scatter(class_a[:, 0], class_a[:, 1], color = 'red', label = 'class -1')
plt.scatter(class_b[:, 0], class_b[:, 1], color = 'green', label = 'class 1')

plt.contourf(decision_boundary[0], decision_boundary[1], decision_boundary[2], cmap = 'RdYlGn', alpha = 0.1) # plot decision boundary
plt.xlabel('x_0')
plt.ylabel('x_1')
plt.title('green area is 1.5x_0 + x_1 - 5 > 0, red area is 1.5x_0 + x_1 - 5 < 0')

plt.legend()
plt.show()